# QiitaApp（Qiita検索アプリ）
![output](https://user-images.githubusercontent.com/64976657/101054665-78219780-35cc-11eb-88a3-11cd5f0f4f38.gif)


## 動作環境
* 【Xcode】Version 12.0.1
* 【Swift】Version 5.3
* 【CocoaPods】version 1.9.3
* 【Alamofire】version 5.4.0


## 紹介
#### QiitaAPIを用いた記事検索アプリになります。
#### 主な機能

１． 記事一覧  
* 新着、iOS、Swiftの記事を表示しております。
* XLPagerTabStripを使用して、タブの切り替えをしております。
* 下までスクロールするとAPI通信を行い追加で記事を読み込み表示するようにしております。（最大100件）

２．記事詳細
* 記事のセルをタップでWebViewで記事の詳細を表示しております。
* ローディングはNVActivityIndicatorViewを使用しました。

３． 検索
* QiitaAPIにタグ情報が含まれているので、そのタグを使用して検索をかけています。

４． 検索履歴
* 検索履歴はUserDefaultsに保存しています。
* 同じワードで検索された場合は、検索履歴に二重で表示されないよう制御しています。
* 右の✖︎ボタンをクリックすると削除できるようにし、検索履歴のワードをタップすると、そのワードで検索がかかるようにしております。


## 目的
#### 1. API通信の基礎的な学習
App Storeにアプリをリリースしたり、学習の過程で色々とアプリを作成した中で、Swift言語のみだと端末上で完結する簡単なアプリになってしまうことに気づきました。APIを用いて外部との連携を取り入れることで、iOSアプリの機能を広げられると思いましたので、初歩ではありますが、今回はQiitaAPIの記事を取得というテーマで取り組みました。

#### 2. API通信でのエラーハンドリングを実装
エラーやバグが発生しない設計も重要ですが、ユーザーの存在がある以上、発生した時の対処も重要なことだと考えました。外部とのやり取りをする上で設計側の予期せぬ通信エラーはつきものだと思っておりますので、まずは、今回作成したアプリではどのようなエラーが考えられるか検討し、実装することにしました。

#### 3. アーキテクチャ _MVP_ を意識したコード設計
学習して間もない頃はViewControllerにまとめて書いておりましたが、コード量が増えすぎると可読性が悪くなり、非効率だと感じるようになりました。テストコードの導入も踏まえ今回は _MVP_ を意識したコード設計をすることにしました。

#### 4. テストコードの導入
シュミレータにて動作確認の検証を行うことはできますが、やはり時間がかかることや、手作業なのでどうしても漏れが発生すると思います。  
自動テストを導入することにより、時間短縮や漏れ防止のメリットに加え、バグの発生を早い段階で気づくことができたり、バグが発生した際にテスト対象外に原因があるという判断材料にもなります。自動テスト扱えることができれば作業効率や品質向上につながると考えました。今回はXcodeのユニットテストフレームワークであるXCTestを用いて、自動テストを導入しました。


## ライブラリ選定
#### 1. XLPagerTabStrip
記事一覧のタブ切り替えに使用しております。  
Twitterやスマートニュースのようなタブ型で切り替えできる画面UIにしたかったのと、おしゃれで評判も良かったので選定することにしました。

#### 2. Alamofire
QiitaAPIを取得する際の通信処理に使用しております。  
ネットワーク通信において企業でもよく使用されている有名なライブラリで、情報量も多かったりと実績のあるライブラリであったので選定することにしました。

#### 3. Nuke
記事のプロフィール画像をキャッシュするのに使用しました。  
自分で実際に検証したわけではありませんが、Swiftの画像キャッシュライブラリを比較した記事を参考に、今回の用途としまして画像の表示のみでしたので、比較で一番処理速度の早かったNukeを選定することにしました。

#### 4. NVActivityIndicatorView
ローディングの際に使用しております。  
UIKitで用意されているUIActivityIndicatorViewは使用したことがあったので、今回は違ったパターンでローディングを実装しようと考えました。NVActivityIndicatorViewは豊富な種類があり導入方法が容易だったのと、Githubのcommit履歴が新しく頻繁に更新されているようだったので選定することにしました。


## 工夫した箇所
#### 1. 1 Storyboard - 1 Controller
全部の画面が1つのStoryboardに集約されていると複数人で共同作業をするにあたり、作業者が限られしまいますので作業効率の悪化につながると考えました。チームでの開発を考慮し、メンテナンスのしやすい設計をするようにしました。

#### 2. 画面遷移の責務分割
_MVP_ のViewの役割として「画面の更新」が主ですが、設計していくなかで「画面遷移」の処理もViewが担当していることに気づきました。今回は画面遷移を管理する別クラスを設けることで、Viewの役割から「画面遷移」の処理を無くし、責務を減らすことで可読性を上げるようにしました。


## チャレンジだった点
#### 1. エラーハンドリング
エラーハンドリングを検討するのが初めてだったので、エラーの向き合い方から考えることにしました。   
1. 使用するAPIからどんなエラーがどういう形式で返ってくるかを把握
2. ユーザー側に知らせるエラー、開発者側のみに知らせるエラーの分類
3. 設計、実装をする

上記に基づき今回は下記内容に分類しました。
* 圏外等のネットワークエラー（ユーザー側）
* 接続のタイムアウト（ユーザー側）
* その他の通信エラー（ユーザー側、サーバー側）
* 検索結果０（ユーザー側）

「検索結果０」に関してはエラーではなく取得成功でかえってくるので、取得したデータを格納する変数のカウントが０で合った場合にユーザーに知らせるようにしました。

#### 2. テストコード導入
テストコードを導入するにあたり、「テストの対象となるものは何か」、「テストを実行するためのダミーをどのように用意するのか」の２点を理解するのに苦戦しました。今回は下記の処理をテスト対象とします。
* API取得時に意図した処理が呼ばれること
* 取得したデータを格納した変数から、意図したデータを呼び出すこと
* UserDefaultsから、意図した内容を呼び出すこと

